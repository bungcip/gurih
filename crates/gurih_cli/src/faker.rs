use fake::faker::address::en::{BuildingNumber, StreetName};
use fake::faker::company::en::CompanyName;
use fake::faker::internet::en::FreeEmail;
use fake::faker::lorem::en::{Paragraph, Sentence};
use fake::faker::name::en::Name;
use fake::faker::phone_number::en::PhoneNumber;
use fake::{Fake, Faker};
use gurih_ir::{FieldType, Schema, Symbol};
use gurih_runtime::datastore::DataStore;
use rand::Rng;
use rand::prelude::IndexedRandom;
use serde_json::{Map, Value};
use std::collections::{HashMap, VecDeque};
use uuid::Uuid;

pub struct FakerEngine;

impl Default for FakerEngine {
    fn default() -> Self {
        Self::new()
    }
}

impl FakerEngine {
    pub fn new() -> Self {
        Self
    }

    pub async fn seed_entities(&self, schema: &Schema, datastore: &dyn DataStore, count: usize) -> Result<(), String> {
        // 1. Topological sort of entities based on dependencies
        let sorted_entities = self.sort_entities(schema)?;

        println!("Faker: Seeding order: {:?}", sorted_entities);

        // 2. Generate data for each entity
        for entity_name in sorted_entities {
            if let Some(entity_schema) = schema.entities.get(&entity_name) {
                println!("Faker: Seeding entity '{}'...", entity_name);

                // Determine if we need to fetch foreign keys
                let mut foreign_keys: HashMap<String, Vec<String>> = HashMap::new();

                // 1. Explicit fields with references
                for field in &entity_schema.fields {
                    if let Some(target_entity) = &field.references {
                        if schema.entities.contains_key(target_entity) {
                            if let Some(target_schema) = schema.entities.get(target_entity) {
                                // Fetch IDs from the target entity using its table_name
                                // We use list with a large limit. In a real scenario, we might want to optimize this.
                                let records = datastore
                                    .list(&target_schema.table_name.to_string(), Some(1000), None)
                                    .await?;
                                let ids: Vec<String> = records
                                    .iter()
                                    .filter_map(|r| r.get("id").and_then(|v| v.as_str()).map(|s| s.to_string()))
                                    .collect();

                                if ids.is_empty() {
                                    println!(
                                        "Warning: No records found for referenced entity '{}'. Field '{}' might fail or be null.",
                                        target_entity, field.name
                                    );
                                }

                                foreign_keys.insert(field.name.to_string(), ids);
                            }
                        }
                    }
                }

                // 2. Implicit BelongsTo relationships
                for rel in &entity_schema.relationships {
                    if rel.rel_type == gurih_ir::RelationshipType::BelongsTo {
                        let field_name = format!("{}_id", rel.name);
                        // Check if already handled by explicit field
                        if let std::collections::hash_map::Entry::Vacant(e) = foreign_keys.entry(field_name) {
                            // Fetch IDs from target_entity using its table_name
                            if let Some(target_schema) = schema.entities.get(&rel.target_entity) {
                                let records = datastore
                                    .list(&target_schema.table_name.to_string(), Some(1000), None)
                                    .await?;
                                let ids: Vec<String> = records
                                    .iter()
                                    .filter_map(|r| r.get("id").and_then(|v| v.as_str()).map(|s| s.to_string()))
                                    .collect();
                                e.insert(ids);
                            }
                        }
                    }
                }

                for _ in 0..count {
                    let mut record = Map::new();

                    for field in &entity_schema.fields {
                        // Skip auto-generated fields if not needed, but sometimes we need to send them?
                        // Typically ID is generated by store.
                        if field.field_type == FieldType::Pk || field.field_type == FieldType::Serial {
                            continue;
                        }

                        let value = if let Some(fks) = foreign_keys.get(&field.name.to_string()) {
                            fks.choose(&mut rand::rng())
                                .map(|id| Value::String(id.clone()))
                                .unwrap_or(Value::Null)
                        } else {
                            self.generate_value(&field.field_type, &field.name.to_string())
                        };

                        if !value.is_null() {
                            record.insert(field.name.to_string(), value);
                        }
                    }

                    // Handle implicit relationships
                    for rel in &entity_schema.relationships {
                        if rel.rel_type == gurih_ir::RelationshipType::BelongsTo {
                            let field_name = format!("{}_id", rel.name);
                            if !record.contains_key(&field_name)
                                && let Some(fks) = foreign_keys.get(&field_name)
                                && !fks.is_empty()
                            {
                                let mut rng = rand::rng();
                                let id = fks.choose(&mut rng).unwrap();
                                record.insert(field_name, Value::String(id.clone()));
                            }
                        }
                    }

                    if let Err(e) = datastore
                        .insert(&entity_schema.table_name.to_string(), Value::Object(record))
                        .await
                    {
                        // Ignore some errors? duplicate unique?
                        // For faker, we might want to retry or just log.
                        // But let's return error to stop if something is wrong.
                        println!("Error inserting fake record: {}", e);
                    }
                }
            }
        }

        Ok(())
    }

    fn sort_entities(&self, schema: &Schema) -> Result<Vec<Symbol>, String> {
        let mut adj: HashMap<Symbol, Vec<Symbol>> = HashMap::new();
        let mut in_degree: HashMap<Symbol, usize> = HashMap::new();

        // Initialize
        for entity in schema.entities.keys() {
            adj.entry(*entity).or_default();
            in_degree.insert(*entity, 0);
        }

        // Build Graph
        for (entity_name, entity_schema) in &schema.entities {
            for rel in &entity_schema.relationships {
                if rel.rel_type == gurih_ir::RelationshipType::BelongsTo
                    && rel.target_entity != *entity_name
                    && schema.entities.contains_key(&rel.target_entity)
                {
                    // target -> entity
                    adj.entry(rel.target_entity).or_default().push(*entity_name);
                    *in_degree.entry(*entity_name).or_insert(0) += 1;
                }
            }

            // Also check fields with references (explicit FKs)
            for field in &entity_schema.fields {
                if let Some(target) = &field.references
                    && target != entity_name
                    && schema.entities.contains_key(target)
                {
                    adj.entry(*target).or_default().push(*entity_name);
                    *in_degree.entry(*entity_name).or_insert(0) += 1;
                }
            }
        }

        // Kahn's Algorithm
        let mut queue: VecDeque<Symbol> = VecDeque::new();
        for (entity, &degree) in &in_degree {
            if degree == 0 {
                queue.push_back(*entity);
            }
        }

        let mut sorted = Vec::new();
        while let Some(u) = queue.pop_front() {
            sorted.push(u);

            if let Some(neighbors) = adj.get(&u) {
                for v in neighbors {
                    if let Some(d) = in_degree.get_mut(v) {
                        *d -= 1;
                        if *d == 0 {
                            queue.push_back(*v);
                        }
                    }
                }
            }
        }

        if sorted.len() != schema.entities.len() {
            // Add remaining entities to the list to allow faker to at least TRY to seed them.
            // This handles cases where there might be cycles or unresolved dependencies.
            for (entity, &degree) in &in_degree {
                if degree > 0 {
                    sorted.push(*entity);
                }
            }
        }

        Ok(sorted)
    }

    fn generate_value(&self, field_type: &FieldType, field_name: &str) -> Value {
        match field_type {
            FieldType::Pk | FieldType::Serial => Value::Null,
            FieldType::Sku => Value::String(
                (0..8)
                    .map(|_| rand::rng().sample(rand::distr::Alphanumeric) as char)
                    .collect::<String>()
                    .to_uppercase(),
            ),
            FieldType::Name => Value::String(Name().fake()),
            FieldType::Title => Value::String(Sentence(3..6).fake()),
            FieldType::Description | FieldType::Text => Value::String(Paragraph(1..3).fake()),
            FieldType::Avatar | FieldType::Image => {
                Value::String(format!("https://placehold.co/400?text={}", field_name))
            }
            FieldType::Money => {
                // Money must be a string (e.g., "123.45")
                let val: f64 = rand::rng().random_range(10.0..1000.0);
                Value::String(format!("{:.2}", val))
            }
            FieldType::Email => Value::String(FreeEmail().fake()),
            FieldType::Phone => Value::String(PhoneNumber().fake()),
            FieldType::Address => Value::String(format!(
                "{} {}",
                BuildingNumber().fake::<String>(),
                StreetName().fake::<String>()
            )),
            FieldType::Password => Value::String("password123".to_string()), // Default password
            FieldType::Enum(options) => {
                if options.is_empty() {
                    Value::Null
                } else {
                    let mut rng = rand::rng();
                    let opt = options.choose(&mut rng).unwrap();
                    Value::String(opt.to_string())
                }
            }
            FieldType::Integer => Value::Number(serde_json::Number::from(rand::rng().random_range(0..100))),
            FieldType::Float => {
                let v: f64 = rand::rng().random_range(0.0..100.0);
                // Simple float to json number
                serde_json::Number::from_f64(v)
                    .map(Value::Number)
                    .unwrap_or(Value::Null)
            }
            FieldType::Date => {
                // Return string YYYY-MM-DD
                let date: chrono::NaiveDate = Faker.fake();
                Value::String(date.format("%Y-%m-%d").to_string())
            }
            FieldType::Timestamp => {
                let dt: chrono::DateTime<chrono::Utc> = Faker.fake();
                Value::String(dt.to_rfc3339())
            }
            FieldType::String => {
                // If field name contains "name", generate Name
                if field_name.to_lowercase().contains("name") {
                    Value::String(CompanyName().fake())
                } else {
                    Value::String(Sentence(1..3).fake())
                }
            }
            FieldType::File => Value::String("https://placehold.co/file.pdf".to_string()),
            FieldType::Relation => Value::Null, // Should be handled by FK logic, but if not found...
            FieldType::Boolean => Value::Bool(rand::rng().random_bool(0.5)),
            FieldType::Code => Value::String(
                (0..8)
                    .map(|_| rand::rng().sample(rand::distr::Alphanumeric) as char)
                    .collect::<String>(),
            ),
            FieldType::Uuid => Value::String(Uuid::new_v4().to_string()),
            FieldType::Custom(_) => Value::Null,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use gurih_dsl::compile;
    use gurih_runtime::datastore::{DataStore, MemoryDataStore};
    use std::sync::Arc;

    #[tokio::test]
    async fn test_faker_generation() {
        let kdl = r#"
        entity "Department" {
            field "id" type="Pk"
            field "name" type="Name"
        }

        entity "Employee" {
            field "id" type="Pk"
            field "full_name" type="Name"
            field "email" type="Email"

            belongs_to "Department"
        }
        "#;

        let schema = compile(kdl, None).expect("Schema compilation failed");
        let datastore: Arc<dyn DataStore> = Arc::new(MemoryDataStore::new());

        let faker = FakerEngine::new();
        faker
            .seed_entities(&schema, datastore.as_ref(), 10)
            .await
            .expect("Faker failed");

        // Verify Department count
        let count_dept = datastore
            .count("department", std::collections::HashMap::new())
            .await
            .unwrap();
        assert_eq!(count_dept, 10);

        // Verify Employee count
        let count_emp = datastore
            .count("employee", std::collections::HashMap::new())
            .await
            .unwrap();
        assert_eq!(count_emp, 10);

        // Verify Relationship (Employee has department_id)
        // FakerEngine handles implicit belongs_to by adding {rel_name}_id field.
        // We need to guess the relationship name. Usually "department" if target is "Department".

        let employees = datastore.list("employee", None, None).await.unwrap();
        // Debug print keys to see what was inserted
        if let Some(first) = employees.first() {
            println!("Employee keys: {:?}", first.as_object().unwrap().keys());
        }

        for emp in employees {
            // Try finding any field ending in _id that is not id
            let fk_key = emp.as_object().unwrap().keys().find(|k| k.ends_with("_id"));

            if let Some(key) = fk_key {
                let val = emp.get(key).unwrap();
                assert!(val.is_string(), "FK should be string (UUID)");
                let dept_id = val.as_str().unwrap();

                // Check if dept exists
                let dept = datastore.get("department", dept_id).await.unwrap();
                assert!(dept.is_some(), "Referenced Department should exist for key {}", key);
            } else {
                panic!(
                    "Employee should have department_id populated by FakerEngine for implicit relationship. Found keys: {:?}",
                    emp.as_object().unwrap().keys()
                );
            }
        }
    }

    #[tokio::test]
    async fn test_faker_generation_non_existent_reference() {
        let kdl = r#"
        entity "EntityWithBadRef" {
            field "id" type="Pk"
            field "bad_ref" type="Relation" references="NonExistentEntity"
        }
        "#;

        let schema = compile(kdl, None).expect("Schema compilation failed");
        let datastore: Arc<dyn DataStore> = Arc::new(MemoryDataStore::new());

        let faker = FakerEngine::new();
        // Should not panic, should skip the reference
        faker
            .seed_entities(&schema, datastore.as_ref(), 10)
            .await
            .expect("Faker failed");

        // Verify records exist
        let records = datastore
            .list("entity_with_bad_ref", None, None)
            .await
            .expect("Failed to list");
        assert_eq!(records.len(), 10);

        // Verify bad_ref is null or missing
        for record in records {
            // It might be missing because faker skips null values
            if let Some(val) = record.get("bad_ref") {
                assert!(val.is_null(), "bad_ref should be null, found {:?}", val);
            }
        }
    }
}
