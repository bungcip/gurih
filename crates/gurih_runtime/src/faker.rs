use crate::datastore::DataStore;
use fake::faker::address::en::{BuildingNumber, StreetName};
use fake::faker::company::en::CompanyName;
use fake::faker::internet::en::FreeEmail;
use fake::faker::lorem::en::{Paragraph, Sentence};
use fake::faker::name::en::Name;
use fake::faker::phone_number::en::PhoneNumber;
use fake::{Fake, Faker};
use gurih_ir::{FieldType, Schema, Symbol};
use rand::Rng;
use rand::seq::SliceRandom;
use serde_json::{Map, Value};
use std::collections::{HashMap, VecDeque};

pub struct FakerEngine;

impl Default for FakerEngine {
    fn default() -> Self {
        Self::new()
    }
}

impl FakerEngine {
    pub fn new() -> Self {
        Self
    }

    pub async fn seed_entities(&self, schema: &Schema, datastore: &dyn DataStore, count: usize) -> Result<(), String> {
        // 1. Topological sort of entities based on dependencies
        let sorted_entities = self.sort_entities(schema)?;

        println!("Faker: Seeding order: {:?}", sorted_entities);

        // 2. Generate data for each entity
        for entity_name in sorted_entities {
            if let Some(entity_schema) = schema.entities.get(&entity_name) {
                println!("Faker: Seeding entity '{}'...", entity_name);

                // Determine if we need to fetch foreign keys
                let mut foreign_keys: HashMap<String, Vec<String>> = HashMap::new();

                // 1. Explicit fields with references
                for field in &entity_schema.fields {
                    if let Some(target_entity) = &field.references {
                        // Fetch IDs from the target entity
                        // We use list with a large limit. In a real scenario, we might want to optimize this.
                        let records = datastore.list(&target_entity.to_string(), Some(1000), None).await?;
                        let ids: Vec<String> = records
                            .iter()
                            .filter_map(|r| r.get("id").and_then(|v| v.as_str()).map(|s| s.to_string()))
                            .collect();

                        if ids.is_empty() {
                            println!(
                                "Warning: No records found for referenced entity '{}'. Field '{}' might fail or be null.",
                                target_entity, field.name
                            );
                        }

                        foreign_keys.insert(field.name.to_string(), ids);
                    }
                }

                // 2. Implicit BelongsTo relationships
                for rel in &entity_schema.relationships {
                    if rel.rel_type == gurih_ir::RelationshipType::BelongsTo {
                        let field_name = format!("{}_id", rel.name);
                        // Check if already handled by explicit field
                        if let std::collections::hash_map::Entry::Vacant(e) = foreign_keys.entry(field_name) {
                            // Fetch IDs from target_entity
                            let records = datastore.list(&rel.target_entity.to_string(), Some(1000), None).await?;
                            let ids: Vec<String> = records
                                .iter()
                                .filter_map(|r| r.get("id").and_then(|v| v.as_str()).map(|s| s.to_string()))
                                .collect();
                            e.insert(ids);
                        }
                    }
                }

                for _ in 0..count {
                    let mut record = Map::new();

                    for field in &entity_schema.fields {
                        // Skip auto-generated fields if not needed, but sometimes we need to send them?
                        // Typically ID is generated by store.
                        if field.field_type == FieldType::Pk || field.field_type == FieldType::Serial {
                            continue;
                        }

                        let value = if let Some(fks) = foreign_keys.get(&field.name.to_string()) {
                            if !fks.is_empty() {
                                let mut rng = rand::thread_rng();
                                let id = fks.choose(&mut rng).unwrap();
                                Value::String(id.clone())
                            } else {
                                Value::Null
                            }
                        } else {
                            self.generate_value(&field.field_type, &field.name.to_string())
                        };

                        if !value.is_null() {
                            record.insert(field.name.to_string(), value);
                        }
                    }

                    // Handle implicit relationships
                    for rel in &entity_schema.relationships {
                        if rel.rel_type == gurih_ir::RelationshipType::BelongsTo {
                            let field_name = format!("{}_id", rel.name);
                            if !record.contains_key(&field_name)
                                && let Some(fks) = foreign_keys.get(&field_name)
                                && !fks.is_empty()
                            {
                                let mut rng = rand::thread_rng();
                                let id = fks.choose(&mut rng).unwrap();
                                record.insert(field_name, Value::String(id.clone()));
                            }
                        }
                    }

                    if let Err(e) = datastore.insert(&entity_name.to_string(), Value::Object(record)).await {
                        // Ignore some errors? duplicate unique?
                        // For faker, we might want to retry or just log.
                        // But let's return error to stop if something is wrong.
                        println!("Error inserting fake record: {}", e);
                    }
                }
            }
        }

        Ok(())
    }

    fn sort_entities(&self, schema: &Schema) -> Result<Vec<Symbol>, String> {
        let mut adj: HashMap<Symbol, Vec<Symbol>> = HashMap::new();
        let mut in_degree: HashMap<Symbol, usize> = HashMap::new();

        // Initialize
        for entity in schema.entities.keys() {
            adj.entry(*entity).or_default();
            in_degree.insert(*entity, 0);
        }

        // Build Graph
        for (entity_name, entity_schema) in &schema.entities {
            for rel in &entity_schema.relationships {
                if rel.rel_type == gurih_ir::RelationshipType::BelongsTo {
                    // target -> entity
                    adj.entry(rel.target_entity).or_default().push(*entity_name);
                    *in_degree.entry(*entity_name).or_insert(0) += 1;
                }
            }

            // Also check fields with references (explicit FKs)
            for field in &entity_schema.fields {
                if let Some(target) = &field.references {
                    // target -> entity
                    // Avoid double counting if relationship is already defined
                    // But strictly speaking, field reference implies dependency too.
                    // We should add it if not already covered.
                    // Since we use in-degree map, simple check is fine.
                    // However, multiple dependencies from same entity is fine.

                    // Check if this dependency is already captured by relationship?
                    // Sometimes relationships are defined without explicit field reference in `relationships` block,
                    // or vice versa. The schema compiler might normalize this.
                    // Let's safe-guard against self-reference or existing edge.
                    if target != entity_name {
                        // Check if edge exists?
                        // It's cheaper to just add and handle duplicates or let logic handle multiple edges.
                        // Kahn's algo handles multi-edges fine (in-degree will be higher).
                        adj.entry(*target).or_default().push(*entity_name);
                        *in_degree.entry(*entity_name).or_insert(0) += 1;
                    }
                }
            }
        }

        // Kahn's Algorithm
        let mut queue: VecDeque<Symbol> = VecDeque::new();
        for (entity, &degree) in &in_degree {
            if degree == 0 {
                queue.push_back(*entity);
            }
        }

        let mut sorted = Vec::new();
        while let Some(u) = queue.pop_front() {
            sorted.push(u);

            if let Some(neighbors) = adj.get(&u) {
                for v in neighbors {
                    if let Some(d) = in_degree.get_mut(v) {
                        *d -= 1;
                        if *d == 0 {
                            queue.push_back(*v);
                        }
                    }
                }
            }
        }

        if sorted.len() != schema.entities.len() {
            // Check for cycles or missing nodes?
            // Actually, `in_degree` map only contains entities from `schema.entities`.
            // So if sorted.len() < entities.len(), there is a cycle.
            // But wait, what if I added an edge for a `target` that is NOT in `schema.entities`?
            // (e.g. invalid reference).
            // `adj` was initialized with keys from entities.
            // But `adj.entry(target)` might create a new entry if target is invalid.
            // `in_degree` was initialized.
            // If I push to `adj` for a target that doesn't exist in `in_degree`, it's a dead end.
            // But `in_degree` won't be updated for that target.

            return Err("Cycle detected in entity relationships or unresolved dependencies.".to_string());
        }

        Ok(sorted)
    }

    fn generate_value(&self, field_type: &FieldType, field_name: &str) -> Value {
        match field_type {
            FieldType::Pk | FieldType::Serial => Value::Null,
            FieldType::Sku => Value::String(
                (0..8)
                    .map(|_| rand::thread_rng().sample(rand::distributions::Alphanumeric) as char)
                    .collect::<String>()
                    .to_uppercase(),
            ),
            FieldType::Name => Value::String(Name().fake()),
            FieldType::Title => Value::String(Sentence(3..6).fake()),
            FieldType::Description | FieldType::Text => Value::String(Paragraph(1..3).fake()),
            FieldType::Avatar | FieldType::Image => {
                Value::String(format!("https://placehold.co/400?text={}", field_name))
            }
            FieldType::Money => {
                // Store as integer cents usually? Or float?
                // Prompt says "Money -> Random money amounts (as integers in cents)"
                Value::Number(serde_json::Number::from(rand::thread_rng().gen_range(1000..100000)))
            }
            FieldType::Email => Value::String(FreeEmail().fake()),
            FieldType::Phone => Value::String(PhoneNumber().fake()),
            FieldType::Address => Value::String(format!(
                "{} {}",
                BuildingNumber().fake::<String>(),
                StreetName().fake::<String>()
            )),
            FieldType::Password => Value::String("password123".to_string()), // Default password
            FieldType::Enum(options) => {
                if options.is_empty() {
                    Value::Null
                } else {
                    let mut rng = rand::thread_rng();
                    let opt = options.choose(&mut rng).unwrap();
                    Value::String(opt.to_string())
                }
            }
            FieldType::Integer => Value::Number(serde_json::Number::from(rand::thread_rng().gen_range(0..100))),
            FieldType::Float => {
                let v: f64 = rand::thread_rng().gen_range(0.0..100.0);
                // Simple float to json number
                serde_json::Number::from_f64(v)
                    .map(Value::Number)
                    .unwrap_or(Value::Null)
            }
            FieldType::Date => {
                // Return string YYYY-MM-DD
                let date: chrono::NaiveDate = Faker.fake();
                Value::String(date.format("%Y-%m-%d").to_string())
            }
            FieldType::Timestamp => {
                let dt: chrono::DateTime<chrono::Utc> = Faker.fake();
                Value::String(dt.to_rfc3339())
            }
            FieldType::String => {
                // If field name contains "name", generate Name
                if field_name.to_lowercase().contains("name") {
                    Value::String(CompanyName().fake())
                } else {
                    Value::String(Sentence(1..3).fake())
                }
            }
            FieldType::File => Value::String("https://placehold.co/file.pdf".to_string()),
            FieldType::Relation => Value::Null, // Should be handled by FK logic, but if not found...
            FieldType::Boolean => Value::Bool(rand::thread_rng().gen_bool(0.5)),
            FieldType::Code => Value::String(
                (0..8)
                    .map(|_| rand::thread_rng().sample(rand::distributions::Alphanumeric) as char)
                    .collect::<String>(),
            ),
            FieldType::Custom(_) => Value::Null,
        }
    }
}
